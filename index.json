[{"content":"[CAS]   TGT: 一种情况是tgt是一个对象，类似session，是验证成功之后创建的。存着一些信息，这种情况下tgc值就是tgt对象的id。另一种情况是tgt是一个字符串，那么tgc的值就是tgt，tgt还是需要关联session存储一些信息。 TGC: cookie，基本存储的就是tgt或者tgt的id。 TK : 从cas sever中获取, (cas实现是)根据tgt和service随机生成。   sequenceDiagram title: CAS的非代理的过程 participant Browser participant cas server participant app Browser-app: GET www.app.com note right of app: 未授权 app--Browser: 重定向到www.cas.com?\\nservice=www.app.coBrowsernt-cas server:GET www.cas.com?\\nservice=www.app.com note right of cas server: 未登入 cas server--Browser: login form Browser- cas server: POST login form + service参数 note right of cas server: 登入成功，生成TGT\\n关联tgc cas server--Browser:设置cookie(TGC:用于查找TGT)，\\n并且带参数TK,重定向到server的uri Browser-app: GET www.app.com?ticket=XXX note right of app:拿到tk,需要验证授权 app-cas server:GET www.cas.com?tk=xxx\u0026service=www.app.com note left of cas server:验证通过 cas server--app:带有成功属性的xml note right of app:生成session app--Browser:设置cookie里为session id，重定向到www.app.com Browser-app:cookie里带有session id，GET www.app.com note right of app:验证session存在 app--Browser:登入成功  第二次登入该app： 由于浏览器中还存在该cookie（TGC），再次访问app时，app根据cookie中的信息找到对应的TGT直接登入成功。 访问其他未访问过的 appB: 由于浏览器没有存储过appB的cookie，所以链接的时候,appB会认为该链接未授权，并且重定向到cas服务器,浏览器的cookie中存在cas的tgc信息，cas检测到之后，找到对应的TGT，并且重定向到appB并且带参数tk。appB检测到tk之后向cas请求验证，之后和上面的流程图一样。\n cas协议摘要: /login接口 一、作为凭证请求者：如果客户端已经和cas server已经建立过session，那么会有一个tgc(ticket granting cookie),其包含了一个key(即tgt对象的id),如果它对到一个合法的tgt，那么cas server会给客户端签发一个st(service ticket)。 参数: 在/login作为请求者的时候,会有以下参数，并且大小写敏感。\n  service(可选): 客户端希望请求的地址，这个url必须被URL-encode过 renew(可选): 如果该参数存在，跳过单点登入，要求客户端必须重新验证。 gatewat(可选): 不可以与renew一起使用，设置之后不要求客户端验证 method(可选,CAS 3.0): 回复的时候使用，通常用GET，如果需要用POST可以设置，需要CAS支持。   用户名/密码过程的回复:通常情况下，cas会显示一个登入页面。这个页面必须包含“username”, “password”,和 “lt”. \u0026ldquo;warn\u0026rdquo; 也可以包含，如果service指定了，service也必须是表示的参数。\n验证中心的回复:如果/login请求凭证是有效的，那么会透明的跳转到客户端希望前往的页面。或者提示客户端是和否跳转。如果验证失效，需要返回原因。\nsso的回复:如果已经和cas建立过链接，客户端会提供tgc, 那么会像下面章节的操作。如果renew参数被设置的话，会重新走sso流程。\n二、作为验证者:当 /login接口接收到一系列验证的参数，就会作为一个凭证验证者。 参数：\n  service参数:同上面/login作为请求者。 warn: 如何warn被设置，那么不能透明的跳转，必须提示 method: 同上   用户/密码过程的回复:\n  username(必须) password(必须) lt(可选):login ticket详细内容不讨论。 rememberMe(可选,cas 3.0):如果设置了需要创建一个长期有效的tgt，需要看cas server是和支持。   验证中心: 没有参数要求。\n最终回复:下面的回复必须有一个被返回。\n  当登入成功的时候: 重定向到客户端请求的service并且必须包含一个\u0026rsquo;ticket\u0026rsquo;参数,如果service没有指定,那么需要提示客户端已经登入成功。 如果登入失败，回到/login并且作为一个登入请求。    /logout接口 登出操作需要清除cas session（即tgt），还有tgc。后续login请求都应该被拒绝，直到客户端下次登入。\n参数: service(可选, cas 3.0) 如果service参数被指定，那么登出后，浏览器启动跳转到service指定的url。(2.0中有url参数，3.0中已经失效。)(作用是登出之后显示在页面中，需要用户点击才跳转。个人理解)\n响应: /logout必须展示一个页面如果没有指定service。\nSingle Logout（SLO） cas server可以支持单点登出，即不仅要在cas server登出，并且所有登入过的客户端都需要登出。如果cas支持SLO，那么必须发送一个包含了如下图的信息的HTTP POST请求。给所有注册过service的客户端。客户端也可以不支持SLO POST请求，那么会忽视该次登出。SLO 也可以在cas server session过期的时候使用。\n 点击时的区域标题  服务端行为 服务端会忽略所有请求SLO POST客户端登出请求的错误\n客户端行为 是否处理SLO POST请求取决于客户端。建议通过SLO POST请求中的service ticket清除客户端的session。如果客户端支持请求，那么应该返回一个http状态码\n/validate[cas 1.0] 检查service ticket 是否有效\n参数:\n  service(必须)出的标志。客户端的url。 ticket(必须) 登入的时候签发的st。 renew(可选) 如果设置了该参数，仅仅当登入后的第一次验证有效。之后需要重新登入。   响应 如果成功 yes\u0026lt;LF\u0026gt; 如果失败 no\u0026lt;LF\u0026gt;\n/serviceValidate[cas 2.0] (默认返回xml)检查tk，并且返回一个xml。代理部分不讨论。 参数:\n  service(必须)出的标志。客户端的url。 ticket(必须) 登入的时候签发的st。 pgtual(可选): 不讨论 renew(可选):同上 format(可选):JSON或者XML，默认是XML   响应 如图: 实体介绍（st,tgc,tgt等） service ticket(ST) st是客户端获取cas server登入权限的凭证，是同过上文的/login请求方式，再由cas server签发的。\nst的属性(要求)\n  st仅能提供给(通过/login签发这个st的那个service)service使用 st仅能验证一次，不论验证成功失败，都必须失效。之后还拿这个st的验证全部失败。 cas server应该给st设置一个过期时间当被签发后，如果过期的验证失败 建议返回描述为什么验证失败 检验超时时间一般为5分钟。根据本地安全策略改变 st必须是一个安全的随机数据，不会被猜到。 st必须以ST-开头 服务端必须支持接受32位字符长度，最好支持到256位   ticket-granting cookie tgc是一个http coodie，是cas当链接建立的时候设置的。客户端通过提供一个合法的tgc，可以跳过首次登入的步骤。\ntgc的属性\n  当浏览器的session被销毁的时候，tgc需要被销毁 cas需要限定cookie路径，应该设置为/cas tgc的值需要在合理的时间内不被猜处理。 tgc的命名应该以TGC-开头 tgc的值应该和tgt的规则一样，典型的一种方式是tgc的值就是tgt.   ticket-granting ticket TGT是当/login成功时生成的，TGT和TGC有绑定关系，TGT是用于获取tk的基础。\nTGT的属性\n  tgt用于多次获取tk.tgt不是一次性的，但是有失效周期和过期策略。 tgt必须清除，当客户端登出 tgt必须是一串安全的数据，在合理时间内不被暴力破解 应该以 TGT-开头 建议tgt应该被加密     个人问题和理解整理:  登出的时候需要通知所有客户端，那么就需要存储所有客户端的url, 由于客户端和服务端只有一个tgc和一个tgt，而且tgc只是一个cookie。那么url只能存储在tgt中，并且关联st(查看SLO 章节)。登出的时候通过TGT中的ST-url关系调用所有的客户端登出(调用成功失败忽略)。客户端需要缓存st和session的关系，用于后续删除。 由于客户端缓存了st和session的关系，需要注意当session过期时候，监听并且删除session，否则会内存溢出。 session超时问题: 1.tgt过期，要么实现监听，一旦tgt过期，就通知所有客户端注销。另外一种方式是不通知，客户端已经登入的还可以使用。2. 客户端的session过期，如果tgt还没有过去，客户端再次请求的时候，又会自动登入上，所以这种情况不做特殊处理。      CAS参考资料： https://apereo.github.io/cas/5.0.x/protocol/CAS-Protocol.html https://apereo.github.io/cas/5.0.x/protocol/CAS-Protocol-Specification.html http://www.cnblogs.com/flying607/p/7598248.html\thttps://blog.csdn.net/elim168/article/details/43560737   ","permalink":"https://dullbirdTest.github.io/posts/2023-03-04-cas/","summary":"[CAS] TGT: 一种情况是tgt是一个对象，类似session，是验证成功之后创建的。存着一些信息，这种情况下tgc值就是tgt对象的id。另一种情况是","title":"CAS"},{"content":"@Conditional的作用原理   一般使用在配置类上，或者@Bean的方法上面 {% fold -点击显示 %} @ConditionalOnClass底层其实也是@Conditional, 只是多了些特有的参数 {% endfold %}\n  看一下注解，value是Condition类型的,\n  先来看一下Condition接口\n  1 2 3 4  @FunctionalInterface public interface Condition {  boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); }   下面根据继承体系详细的解释一下 4. ConfigurationCondition接口。是为了描述这个条件类，需要在什么情况下被调用，比如有些情况需要类全部加载了才能判断。例如是否存在XXbean。 {% fold -点击显示 %} {% endfold %} 5. SpringBootCondition是其他的springboot的条件类的抽象父类。 这里使用了模版设计模式 {% fold -点击显示 %}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public abstract class SpringBootCondition implements Condition {   //注意这里是public final的  @Override  public final boolean matches(ConditionContext context,  AnnotatedTypeMetadata metadata) {  // 获取了一下类名称或者方法名称，从注解中  String classOrMethodName = getClassOrMethodName(metadata);  try {  // 获取比较的结果信息，通常由不同的子类实现(重点)  ConditionOutcome outcome = getMatchOutcome(context, metadata);  //日志记录  logOutcome(classOrMethodName, outcome);  recordEvaluation(context, classOrMethodName, outcome);  return outcome.isMatch();  }  catch (NoClassDefFoundError ex) {  //略。。  }  }   {% endfold %}\n展示其中一个实现类 OnBeanCondition，注解为@ConditionalOnBean {% fold -点击显示 %}  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Target({ ElementType.TYPE, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @Documented @Conditional(OnBeanCondition.class) public @interface ConditionalOnBean {   Class\u0026lt;?\u0026gt;[] value() default {};   String[] type() default {};   Class\u0026lt;? extends Annotation\u0026gt;[] annotation() default {};   String[] name() default {};   SearchStrategy search() default SearchStrategy.ALL; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @Override public ConfigurationPhase getConfigurationPhase() {  //其中getConfigurationPhase()值为注册完成才能检测。  return ConfigurationPhase.REGISTER_BEAN; }  @Override public ConditionOutcome getMatchOutcome(ConditionContext context,  AnnotatedTypeMetadata metadata) {  ConditionMessage matchMessage = ConditionMessage.empty();  //判断如果是包含ConditionalOnBean注解的  if (metadata.isAnnotated(ConditionalOnBean.class.getName())) {  //构造一些基础信息，该处是获取了@ConditionalOnBean注解里面的所有参数值，见下文  BeanSearchSpec spec = new BeanSearchSpec(context, metadata,  ConditionalOnBean.class);  // 核心匹配方法，通过context获取beanFactory来进行查找。  MatchResult matchResult = getMatchingBeans(context, spec);  //判断结果是否找到  if (!matchResult.isAllMatched()) {  //..略，return  }  matchMessage = matchMessage.andCondition(ConditionalOnBean.class, spec)  .found(\u0026#34;bean\u0026#34;, \u0026#34;beans\u0026#34;)  .items(Style.QUOTE, matchResult.getNamesOfAllMatches());  }  //下面两个平级的if，做了ConditionalOnSingleCandidate注解和ConditionalOnMissingBean注解的解析。大致逻辑一样，细节逻辑不展开。全部比较完成之后才返回结果。  return ConditionOutcome.match(matchMessage); }   {% endfold %}\n那么SpringBoot是这么解析@Contitional的类和@Bean的方法呢？  @Contitional的类的处理 看一个例子: {% fold -点击显示 %} 1 2 3 4 5 6 7  @ConditionalOnClass(ProcessorConfiguration.class) public class CoffeeConfiguration {  @Bean(\u0026#34;mokaCoffee\u0026#34;)  public Coffee createCoffee() {  return new Coffee(\u0026#34;moka\u0026#34;);  } }   {% endfold %} {% fold 源码理解 %}\n1 2 3 4 5 6 7 8  public AnnotationConfigApplicationContext(Class\u0026lt;?\u0026gt;... annotatedClasses) {  //AnnotationConfigApplicationContext的构造函数提供了一个AnnotatedBeanDefinitionReader(主要处理配置文件)和ClassPathBeanDefinitionScanner(扫描指定路径过滤指定的类)，  this();  //context加载@Configuration的时候主要是通过了AnnotationConfigApplicationContext.register(..)方法  register(annotatedClasses);  //beanFactory的处理流程，bean加载的流程  refresh(); }   跟随register往下查看。找到了注册配置类的代码,** AnnotatedBeanDefinitionReader ** 的doRegisterBean，核心是加载配置为BeanDefinition， 这个时候如果你在配置类上添加了@ConditionalOnClass(A.calss)，需要检查A.class存在在加载配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;T\u0026gt; void doRegisterBean(Class\u0026lt;T\u0026gt; annotatedClass, @Nullable Supplier\u0026lt;T\u0026gt; instanceSupplier, @Nullable String name,  @Nullable Class\u0026lt;? extends Annotation\u0026gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {  // 把配置类转换为BeanDefinition  AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);  // (重点)！！查看关注，查看是否需要跳过，即是否有@Conditional修饰  if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {  return;  }   // 略..配置加载的初始化操作  // 加载一共公共的配置注解，比如@Lazy,@Primary,@Role,@Description  AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);  //略..  for (BeanDefinitionCustomizer customizer : definitionCustomizers) {  //如果有自定义的加载自定义的  customizer.customize(abd);  }   //最终注册到registry，即AnnotationConfigApplicationContext  BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);  definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);  BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); }   重点查看this.conditionEvaluator.shouldSkip(abd.getMetadata());代码，此处代码我觉得这个递归调用很奇怪.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  //配置文件进入的时候phase==null public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {  // 如果不是Conditional，直接返回不需要跳过  if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {  return false;  }  // 如果 phase 为null，先确定phase，phase就是确定现在是一个配置文件。比如@Configuration、@Component、@Import等修饰的。确定完phase，循环调用shouldSkip，并且输入phase，实际不会递归。只会执行2次。  if (phase == null) {  if (metadata instanceof AnnotationMetadata \u0026amp;\u0026amp;  ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {  return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);  }  return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);  }   List\u0026lt;Condition\u0026gt; conditions = new ArrayList\u0026lt;\u0026gt;();  // 获取condition对象，并且实例化对象。  for (String[] conditionClasses : getConditionClasses(metadata)) {  for (String conditionClass : conditionClasses) {  Condition condition = getCondition(conditionClass, this.context.getClassLoader());  conditions.add(condition);  }  }  //排序。  AnnotationAwareOrderComparator.sort(conditions);  // 遍历执行  for (Condition condition : conditions) {  ConfigurationPhase requiredPhase = null;  //如果是ConfigurationCondition的condition，直接获取对象的requiredPhase  if (condition instanceof ConfigurationCondition) {  requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();  }  // 比较requiredPhase和当前是都一致(默认为null)，如果不一致，说明该condition在这个条件下不能执行。并且调用condition.matches，如果失败。那么就需要跳过  if ((requiredPhase == null || requiredPhase == phase) \u0026amp;\u0026amp; !condition.matches(this.context, metadata)) {  return true;  }  }   return false; }   {% endfold %}\n@Bean的条件处理   前期知识: {% fold 点击展示 %}  1 2 3 4 5  @FunctionalInterface public interface BeanFactoryPostProcessor {  // spring提供的bean生命周期控制的接口，在所有的bean初始化之前，修改修改bean的定义属性.一般就是修改BeanDefinition  void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; }    AnnotatedBeanDefinitionReader初始化的时候。注册了ConfigurationClassPostProcessor等 BeanFactoryPostProcessor。 查看refresh(); 方法其中是bean加载的核心方法，关注框起来的方法，其中初始化了BeanFactoryPostProcessor，并且调用。 {% endfold %}  {% fold 源码理解 %} {% endfold %} 其中ConfigurationClassPostProcessor的processConfigBeanDefinitions方法 {% fold 源码理解 %}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {  List\u0026lt;BeanDefinitionHolder\u0026gt; configCandidates = new ArrayList\u0026lt;\u0026gt;();  String[] candidateNames = registry.getBeanDefinitionNames();   for (String beanName : candidateNames) {  BeanDefinition beanDef = registry.getBeanDefinition(beanName);  if (..) {  //略  } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(  beanDef, this.metadataReaderFactory)) {  // 所有的bean依次判断是否是配置类(描述的不是那么清楚)  configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));  }  }   //略，判断了异常，进行了排序  // 获取了BeanNameGenerator generator  // 构造了ConfigurationClassParser解析类  ConfigurationClassParser parser = new ConfigurationClassParser(  this.metadataReaderFactory,this.problemReporter, this.environment,  this.resourceLoader,this.componentScanBeanNameGenerator, registry);   Set\u0026lt;BeanDefinitionHolder\u0026gt; candidates = new LinkedHashSet\u0026lt;\u0026gt;(configCandidates);  Set\u0026lt;ConfigurationClass\u0026gt; alreadyParsed = new HashSet\u0026lt;\u0026gt;(configCandidates.size());  do {  //解析配置文件，此处会调用ConditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION).有点疑问，为什么  parser.parse(candidates);  parser.validate();   //略，初始化ConfigurationClassBeanDefinitionReader reader，并且加载configClasses,此时会调用register已经判断了。这里又判断一次  this.reader.loadBeanDefinitions(configClasses);  //略  }  while (!candidates.isEmpty());   //略 }    reader.loadBeanDefinitions(..)-\u0026gt;loadBeanDefinitionsForConfigurationClass(..)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private void loadBeanDefinitionsForConfigurationClass(  ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {  // 判断配置是否需要跳过，conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN);  if (trackedConditionEvaluator.shouldSkip(configClass)) {  //略  return;  }  if (configClass.isImported()) {  //略  }  // 加载每一个@bean的方法，并且判断是否需要加载。this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)  for (BeanMethod beanMethod : configClass.getBeanMethods()) {  loadBeanDefinitionsForBeanMethod(beanMethod);  }   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); }   {% endfold %} 问题：@Component会被加载为配置文件\n","permalink":"https://dullbirdTest.github.io/posts/2023-03-04-conditional%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8E%9F%E7%90%86/","summary":"@Conditional的作用原理 一般使用在配置类上，或者@Bean的方法上面 {% fold -点击显示 %} @ConditionalOnClass底层其实","title":"spring-Conditional"}]